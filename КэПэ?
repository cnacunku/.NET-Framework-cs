using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Coursework_CS_WF
{
    public partial class Coursework_CS_WF : Form
    {
        public Coursework_CS_WF()
        {
            InitializeComponent();

            // Двойная буферизация для панели
            pnlGRAPH.GetType()
            .GetProperty("DoubleBuffered", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic)
            .SetValue(pnlGRAPH, true, null);
        }

        public class Node
        {
            public int X;
            public int Y;
            public string Name;
            public Color Color = Color.FromArgb(220, 187, 255);
        }

        public class Edge
        {
            public Node From;
            public Node To;
        }

        List<Node> nodes = new List<Node>();
        List<Edge> edges = new List<Edge>();

        enum Mode { None, AddNode, AddEdge, Delete, Move }
        Mode currentMode = Mode.None;

        Node firstNode = null;
        Node movingNode = null;
        bool isDragging = false;

        const int NODE_RADIUS = 22;

        private string GenerateNodeName()
        {
            int i = 1;
            while (nodes.Any(n => n.Name == "x" + i))
                i++;
            return "x" + i;
        }

        private void btnAddNode_Click(object sender, EventArgs e)
        {
            currentMode = Mode.AddNode;
            txtMSG.Text = "Режим: Добавление вершин";
        }

        private void btnAddEdge_Click(object sender, EventArgs e)
        {
            currentMode = Mode.AddEdge;
            firstNode = null;
            txtMSG.Text = "Режим: Добавление связи. Выберите две вершины.";
        }

        private void btnDelete_Click(object sender, EventArgs e)
        {
            currentMode = Mode.Delete;
            txtMSG.Text = "Режим: Удаление вершин / рёбер";
        }

        private void pnlGRAPH_MouseDown(object sender, MouseEventArgs e)
        {
            Node clicked = FindNodeAtPoint(e.Location);

            switch (currentMode)
            {
                case Mode.AddNode:
                    int x = Math.Max(NODE_RADIUS, Math.Min(e.X, pnlGRAPH.Width - NODE_RADIUS));
                    int y = Math.Max(NODE_RADIUS, Math.Min(e.Y, pnlGRAPH.Height - NODE_RADIUS));

                    // Генерация уникального имени вершины
                    string name = GenerateNodeName();

                    nodes.Add(new Node
                    {
                        X = x,
                        Y = y,
                        Name = name,
                        Color = Color.FromArgb(220, 187, 255) // цвет вершины
                    });
                    txtMSG.Text = $"Добавлена вершина {name}";
                    pnlGRAPH.Invalidate();
                    break;
                case Mode.AddEdge:
                    if (clicked == null) return;

                    if (firstNode == null)
                    {
                        firstNode = clicked;
                        txtMSG.Text = $"Выбрана первая вершина: {clicked.Name}. Теперь выберите вторую.";
                    }
                    else
                    {
                        // Проверка: нельзя соединять вершину с самой собой
                        if (clicked == firstNode)
                        {
                            txtMSG.Text = "Нельзя создать связь от вершины к самой себе!";
                            firstNode = null; // сброс выбора
                            return;
                        }

                        bool edgeExists = edges.Any(p => p.From == firstNode && p.To == clicked);
                        if (edgeExists)
                        {
                            txtMSG.Text = $"Ребро {firstNode.Name} → {clicked.Name} уже существует!";
                            firstNode = null;
                            return;
                        }

                        edges.Add(new Edge { From = firstNode, To = clicked });
                        txtMSG.Text = $"Связь {firstNode.Name} → {clicked.Name} создана.";
                        firstNode = null;
                        pnlGRAPH.Invalidate();
                    }
                    break;
                case Mode.Delete:
                    if (clicked != null)
                    {
                        edges.RemoveAll(ed => ed.From == clicked || ed.To == clicked);
                        nodes.Remove(clicked);
                        txtMSG.Text = $"Удалена вершина {clicked.Name}";
                    }
                    else
                    {
                        Edge clickedEdge = FindEdgeAtPoint(e.Location);
                        if (clickedEdge != null)
                        {
                            edges.Remove(clickedEdge);
                            txtMSG.Text = $"Удалено ребро {clickedEdge.From.Name} → {clickedEdge.To.Name}";
                            pnlGRAPH.Invalidate();
                        }
                    }
                    pnlGRAPH.Invalidate();
                    break;
                case Mode.Move:
                    if (clicked != null)
                    {
                        movingNode = clicked;
                        isDragging = true;
                    }
                    break;
            }
        }

        private Node FindNodeAtPoint(Point p)
        {
            foreach (var n in nodes)
            {
                double dx = p.X - n.X;
                double dy = p.Y - n.Y;

                if (Math.Sqrt(dx * dx + dy * dy) <= NODE_RADIUS)
                    return n;
            }
            return null;
        }

        private Edge FindEdgeAtPoint(Point p)
        {
            const double tolerance = 9.0; // допустимое расстояние до линии
            foreach (var edge in edges)
            {
                double dx = edge.To.X - edge.From.X;
                double dy = edge.To.Y - edge.From.Y;
                double length = Math.Sqrt(dx * dx + dy * dy);
                if (length == 0) continue;

                double t = ((p.X - edge.From.X) * dx + (p.Y - edge.From.Y) * dy) / (length * length);
                t = Math.Max(0, Math.Min(1, t));
                double closestX = edge.From.X + t * dx;
                double closestY = edge.From.Y + t * dy;

                double distance = Math.Sqrt((p.X - closestX) * (p.X - closestX) + (p.Y - closestY) * (p.Y - closestY));
                if (distance <= tolerance) return edge;
            }
            return null;
        }

        private void DrawArrow(Graphics g, Node from, Node to)
        {
            float dx = to.X - from.X;
            float dy = to.Y - from.Y;
            float dist = (float)Math.Sqrt(dx * dx + dy * dy);

            if (dist < 1) return;

            float nx = dx / dist;
            float ny = dy / dist;

            float startX = from.X + nx * NODE_RADIUS;
            float startY = from.Y + ny * NODE_RADIUS;

            float endX = to.X - nx * NODE_RADIUS;
            float endY = to.Y - ny * NODE_RADIUS;

            using (Pen pen = new Pen(Color.Black, 3))
            {
                pen.EndCap = LineCap.Custom;

                // Стрелка
                AdjustableArrowCap arrow = new AdjustableArrowCap(6, 8); // (ширина, высота)
                pen.CustomEndCap = arrow;

                g.DrawLine(pen, startX, startY, endX, endY);
            }
        }

        private void pnlGRAPH_Paint(object sender, PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            g.SmoothingMode = SmoothingMode.AntiAlias;

            foreach (var edge in edges)
            {
                DrawArrow(g, edge.From, edge.To);
            }

            foreach (var n in nodes)
            {
                g.FillEllipse(new SolidBrush(n.Color),
              n.X - NODE_RADIUS, n.Y - NODE_RADIUS,
              NODE_RADIUS * 2, NODE_RADIUS * 2);

                g.DrawEllipse(Pens.Black,
                              n.X - NODE_RADIUS, n.Y - NODE_RADIUS,
                              NODE_RADIUS * 2, NODE_RADIUS * 2);

                var sf = new StringFormat()
                {
                    Alignment = StringAlignment.Center,
                    LineAlignment = StringAlignment.Center
                };

                g.DrawString(n.Name, new Font("Arial", 11, FontStyle.Bold),
                             Brushes.Black,
                             new RectangleF(n.X - NODE_RADIUS, n.Y - NODE_RADIUS,
                                            NODE_RADIUS * 2, NODE_RADIUS * 2),
                             sf);
            }
        }

        private void btnMove_Click(object sender, EventArgs e)
        {
            currentMode = Mode.Move;
            txtMSG.Text = "Режим: Перемещение вершин. Зажмите ЛКМ на вершине и двигайте.";
        }

        private void pnlGRAPH_MouseMove(object sender, MouseEventArgs e)
        {
            if (currentMode == Mode.Move && isDragging && movingNode != null)
            {
                // Ограничиваем координаты по X
                movingNode.X = Math.Max(NODE_RADIUS, e.X);                 // слева
                movingNode.X = Math.Min(pnlGRAPH.Width - NODE_RADIUS, movingNode.X); // справа

                // Ограничиваем координаты по Y
                movingNode.Y = Math.Max(NODE_RADIUS, e.Y);                 // сверху
                movingNode.Y = Math.Min(pnlGRAPH.Height - NODE_RADIUS, movingNode.Y); // снизу

                pnlGRAPH.Invalidate();
            }
        }

        private void pnlGRAPH_MouseUp(object sender, MouseEventArgs e)
        {
            isDragging = false;
            movingNode = null;
        }

        private void btnSave_Click(object sender, EventArgs e)
        {
            string exePath = Application.StartupPath; // bin\Debug\netX.X
            string projectPath = Directory.GetParent(exePath).Parent.Parent.FullName;
            string folderPath = Path.Combine(projectPath, "Graphs"); // Graphs в корне проекта

            // Создаём папку, если её нет
            if (!Directory.Exists(folderPath))
                Directory.CreateDirectory(folderPath);

            SaveFileDialog sfd = new SaveFileDialog();
            sfd.InitialDirectory = folderPath;   // открываем именно эту папку
            sfd.Filter = "Text files|*.txt";
            sfd.DefaultExt = "txt";
            sfd.FileName = "Graph.txt";          // можно предложить дефолтное имя

            if (sfd.ShowDialog() == DialogResult.OK)
            {
                using (StreamWriter sw = new StreamWriter(sfd.FileName))
                {
                    sw.WriteLine("# Nodes");
                    foreach (var n in nodes)
                        sw.WriteLine($"{n.Name};{n.X};{n.Y};{n.Color.R};{n.Color.G};{n.Color.B}");

                    sw.WriteLine("# Edges");
                    foreach (var f in edges)
                        sw.WriteLine($"{f.From.Name};{f.To.Name}");
                }

                txtMSG.Text = $"Граф сохранён: {sfd.FileName}";
            }
        }

        private void btnOpen_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.Filter = "Text files|*.txt";
            if (ofd.ShowDialog() == DialogResult.OK)
            {
                nodes.Clear();
                edges.Clear();

                var lines = File.ReadAllLines(ofd.FileName);
                bool readingNodes = false;
                bool readingEdges = false;

                foreach (var line in lines)
                {
                    if (line.StartsWith("# Nodes")) { readingNodes = true; readingEdges = false; continue; }
                    if (line.StartsWith("# Edges")) { readingNodes = false; readingEdges = true; continue; }
                    if (string.IsNullOrWhiteSpace(line)) continue;

                    if (readingNodes)
                    {
                        var parts = line.Split(';');
                        nodes.Add(new Node
                        {
                            Name = parts[0],
                            X = int.Parse(parts[1]),
                            Y = int.Parse(parts[2]),
                            Color = Color.FromArgb(int.Parse(parts[3]), int.Parse(parts[4]), int.Parse(parts[5]))
                        });
                    }
                    else if (readingEdges)
                    {
                        var parts = line.Split(';');
                        Node from = nodes.First(n => n.Name == parts[0]);
                        Node to = nodes.First(n => n.Name == parts[1]);
                        edges.Add(new Edge { From = from, To = to });
                    }
                }

                pnlGRAPH.Invalidate();
            }
        }

        private void btnClear_Click(object sender, EventArgs e)
        {
            nodes.Clear();  // удаляем все вершины
            edges.Clear();  // удаляем все рёбра
            firstNode = null; // сбрасываем выбранную вершину для добавления ребра
            movingNode = null; // сброс перетаскивания
            isDragging = false;

            pnlGRAPH.Invalidate(); // перерисовываем панель
            txtMSG.Text = "Полотно очищено";
        }

        private void btnFIND_Click(object sender, EventArgs e)
        {
            // Проверяем, есть ли вершины
            if (nodes.Count == 0)
            {
                MessageBox.Show("Сначала добавьте вершины и рёбра.", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Создаём форму для гамильтоновых цепей/циклов и передаём списки
            HamiltonForm hForm = new HamiltonForm(nodes, edges);

            // Показываем форму модально
            hForm.ShowDialog();
        }
    }
}


//

using Coursework_CS_WF;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Windows.Forms.VisualStyles;
using static Coursework_CS_WF.Coursework_CS_WF;

namespace Coursework_CS_WF
{
    public partial class HamiltonForm : Form
    {
        private List<Node> nodes;
        private List<Edge> edges;

        public HamiltonForm(List<Node> nodes, List<Edge> edges)
        {
            InitializeComponent();
            this.nodes = nodes;
            this.edges = edges;
            FillMatrixM(HdgvMatrix);
            AnalogueFill(HdgvMatrix);
            FindHamiltonianPaths();
        }

        private void HbtnClose_Click(object sender, EventArgs e)
        {
            this.Close();
        }
        private void FillMatrixM(DataGridView dgv)
        {
            dgv.Columns.Clear();
            dgv.Rows.Clear();

            int n = nodes.Count;

            foreach (var node in nodes)
            {
                dgv.Columns.Add(node.Name, node.Name);
                dgv.Columns[dgv.Columns.Count - 1].SortMode = DataGridViewColumnSortMode.NotSortable;
            }

            int maxConnections = nodes.Max(node => edges.Count(e => e.From == node));

            for (int i = 0; i < maxConnections; i++)
                dgv.Rows.Add();

            for (int col = 0; col < n; col++)
            {
                var node = nodes[col];
                var outgoing = edges
                    .Where(e => e.From == node)
                    .Select(e => e.To.Name)
                    .OrderBy(name => name)
                    .ToList();

                for (int row = 0; row < maxConnections; row++)
                {
                    dgv.Rows[row].Cells[col].Value = row < outgoing.Count ? outgoing[row] : "-";
                }
            }
        }

        private void FindHamiltonianPaths()
        {
            List<List<Node>> paths = new List<List<Node>>();
            List<List<Node>> cycles = new List<List<Node>>();

            if (nodes.Count == 0) return;

            List<Node> currentPath = new List<Node>();
            HashSet<Node> visited = new HashSet<Node>();
            Node start = nodes[0];
            currentPath.Add(start);
            visited.Add(start);
            DFS(start, start, currentPath, visited, paths, cycles);

            HtxtMSG.Clear();
            HtxtMSG.AppendText("Гамильтоновы цепи:\r\n");
            int idx = 1;
            foreach (var path in paths)
            {
                HtxtMSG.AppendText($"S{idx} = {{ {string.Join(", ", path.Select(n => n.Name))} }}\r\n");
                idx++;
            }

            HtxtMSG.AppendText("\r\nГамильтоновы циклы:\r\n");
            idx = 1;
            foreach (var cycle in cycles)
            {
                HtxtMSG.AppendText($"S'{idx} = {{ {string.Join(", ", cycle.Select(n => n.Name))} }}\r\n");
                idx++;
            }
        }

        private void DFS(Node current, Node start, List<Node> path, HashSet<Node> visited, List<List<Node>> paths, List<List<Node>> cycles)
        {
            if (visited.Count == nodes.Count)
            {
                paths.Add(new List<Node>(path));

                if (edges.Any(e => e.From == current && e.To == start))
                {
                    List<Node> cycle = new List<Node>(path);
                    cycle.Add(start);
                    cycles.Add(cycle);
                }
                return;
            }

            var nextNodes = edges
                .Where(e => e.From == current)
                .Select(e => e.To)
                .Where(n => !visited.Contains(n))
                .OrderBy(n => n.Name);

            foreach (var next in nextNodes)
            {
                path.Add(next);
                visited.Add(next);
                DFS(next, start, path, visited, paths, cycles);
                visited.Remove(next);
                path.RemoveAt(path.Count - 1);
            }
        }

        private void AnalogueFill(DataGridView dgv)
        {
            int colCount = dgv.Columns.Count;

            if (colCount == 0)
                return;

            if (colCount <= 17)
            {
                dgv.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.None;
                int colWidth = dgv.ClientSize.Width / colCount;

                foreach (DataGridViewColumn col in dgv.Columns)
                    col.Width = colWidth;

                dgv.ScrollBars = ScrollBars.None;
            }
            else
            {
                dgv.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.AllCells; // Скрол
                dgv.ScrollBars = ScrollBars.Both;
            }
        }
    }
}
